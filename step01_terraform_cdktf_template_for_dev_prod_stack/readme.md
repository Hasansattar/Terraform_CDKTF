

Here's a simple example of a **Terraform CDKTF** project written in TypeScript that provisions an **AWS S3 bucket**. It follows the directory structure outlined earlier.

**Step 1: Initialize a Terraform CDKTF Project**
You can initialize a CDKTF project using the following command:

```bash
cdktf init --template="typescript"

```
This creates the basic directory structure and installs the necessary dependencies for your Terraform CDKTF project.

**Step 2: Directory Structure**

The structure will be as follows:

```python
my-terraform-cdk-project/
│
├── cdktf.out/                    # Auto-generated Terraform config (after cdktf synth)
├── main.ts                       # Entry point of the CDKTF app
├── stacks/
│   └── my-stack.ts               # CDKTF stack defining AWS resources
├── config/
│   └── common.ts                 # CDKTF common configuration for all  AWS resources
│   └── dev.ts                    # CDKTF dev configuration for all AWS resources
│   └── prod.ts                   # CDKTF prod configuration for all AWS resources
├── utils/
│   └── config_utils.ts           #  combine all configuration for all  AWS resources
├── .gen/                         # Auto-generated Terraform provider bindings (after cdktf synth)
├── node_modules/                 # Auto-generated by npm/yarn
├── .gitignore                    # Files to ignore in Git
├── cdktf.json                    # CDKTF-specific configuration
├── package.json                  # Project dependencies and scripts
├── tsconfig.json                 # TypeScript configuration
└── README.md                     # Project documentation

```

**Step 3: Code Sample**

``main.ts``

This is the entry point of the application, where you define and instantiate your Terraform stack.

```typescript


import { App} from "cdktf";
import { MyStack } from "./stacks/my-stack";
import { loadConfig } from './utils/config_util';

// Create an instance of the CDKTF App
const app = new App();

const stage = app.node.tryGetContext('stage');

if (!stage || stage === 'unknown') {
  console.error(
    'You need to set the target stage. USAGE: cdk <command> -c stage=dev <stack>',
  );
  process.exit(1);
}


// Load stage config and set cdk environment
let config;
try {
  config = loadConfig(stage);
} catch (error) {
  console.error('Failed to load configuration:', error);
  process.exit(1);
}

console.log("config==========>",config);

// Instantiate the stack
new MyStack(app, `step01_hello_cdktf-${config.stage}`,{
  config: config
});

// Synthesize the stack into Terraform JSON configuration files
app.synth();


```

``stacks/my-stack.ts``

This file defines a CDKTF stack. In this example, the stack provisions an AWS S3 bucket.

```typescript
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
import { AwsProvider } from "@cdktf/provider-aws/lib/provider";
import { S3Bucket  } from "@cdktf/provider-aws/lib/s3-bucket";
import { Instance  } from "@cdktf/provider-aws/lib/instance";


interface MyStackProps {
 config:{
  aws_region: string;
  compute:{
  ec2:{
    os_ami: string;
    os_size: string;
  }
  }
  environment:string;
  stage:string;
 }
}

// Define a custom stack class extending TerraformStack
export class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string, props:MyStackProps) {
    super(scope, id);

    console.log("config in stack",props)

    // Configure the AWS Provider for Terraform
    new AwsProvider(this, "AWS", {
      region: props.config.aws_region, // You can change this to your desired AWS region
    });



    
    new Instance(this,`MyInstance-${props.config.stage}`,{
      ami: props.config.compute.ec2.os_ami,
      instanceType: props.config.compute.ec2.os_size,
      tags: {
        Name: `${props.config.environment}-instance`, // Set the name of the instance
      },
    

    })

    // Define an S3 bucket
    new S3Bucket(this, `MyBucket-${props.config.stage}`, {
      bucket: `my-cdktf-sample-bucket-${props.config.stage}`,  // Replace with a unique bucket name
      acl: "private",                    // Define bucket access level (private, public-read, etc.)
    });
  }
}



```



**step 4: Config yaml for common, dev, prod**


``common.yaml``

```yaml
aws_account: '951882055661'
aws_region: us-east-1
name: YourProjectName
tags:
  app: project_tag
emailAddress: xyz@gmail.com

```


``dev.yaml``

```yaml

environment: development
compute:
  ec2:
    os_ami: ami_123456789
    os_size: t2.micro
      

```

``prod.yaml``

```yaml

environment: production
compute:
  ec2:
    os_ami: ami_123456789
    os_size: t2.small
      

```


**Step 5: Utils to combine all configuration**

``config_util.ts``

```typescript
import { resolve } from 'path';
import { readFileSync } from 'fs';
import * as yaml from 'yaml';
import { merge } from 'lodash';
import { Config } from '../types/types';

export function loadConfig(stage:Config['stage']):Config{
  // Load common file
  let commonConfig = {};
  try {
    // commonConfig = yaml.parseDocument(resolve(__dirname, '../config/common.yaml'))
    commonConfig = yaml.parse(
      readFileSync(resolve(__dirname, '../config/common.yaml'), 'utf8'),
    );
  } catch (err) {
    console.log('No config found in config/common.yaml.');
  }
  console.log("commonConfig==>",commonConfig);

  // Load stage specific file
  let envConfig = {};
  try {
    envConfig = yaml.parse(
      readFileSync(resolve(__dirname, `../config/${stage}.yaml`), 'utf8'),
    );
  } catch (err) {
    console.log(`No config found in config/${stage}.yaml`);
  }

  console.log("envConfig===>",envConfig);

  // Merge the configs
  const mergedConfig = merge({}, commonConfig, envConfig) as Config;;
  // Extract stage to set env
    mergedConfig['stage'] = stage;
 // mergedConfig['ssm_infra'] = `/clubsoul/infra/${stage}/`;

  console.log(mergedConfig);

  return mergedConfig;
}
```


**Step 6: Configuration Files**

``cdktf.json``

This file contains the configuration for the Terraform CDK. It specifies the language, output directory, and more.

```json
{
  "language": "typescript",
  "app": "npx ts-node main.ts",
  "projectId": "89bc4532-d1a2-410e-a533-90a05ed7f8d7",
  "sendCrashReports": "true",
  "terraformProviders": [],
  "terraformModules": [],
  "context": {
    "stage":"dev",
    "allowSepCharsInLogicalIds": "true"
    
  },
  
}


``` 

``package.json``

This file defines the project dependencies, scripts, and configuration for the TypeScript CDKTF project.

```json
{
  "name": "step00_hello_cdktf",
  "version": "1.0.0",
  "main": "main.js",
  "types": "main.ts",
  "license": "MPL-2.0",
  "private": true,
  "scripts": {
    "get": "cdktf get",
    "build": "tsc",
    "synth": "cdktf synth",
    "compile": "tsc --pretty",
    "watch": "tsc -w",
    "test": "jest",
    "test:watch": "jest --watch",
    "upgrade": "npm i cdktf@latest cdktf-cli@latest",
    "upgrade:next": "npm i cdktf@next cdktf-cli@next"
  },
  "engines": {
    "node": ">=18.0"
  },
  "dependencies": {
    "@cdktf/provider-aws": "^19.33.0", 
    "cdktf": "^0.20.8",
    "constructs": "^10.3.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.13",
    "@types/node": "^22.5.5",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2"
  }
}

```

**Step 7: Deploy the Infrastructure**

Install Dependencies: Run the following command to install the required dependencies:

```bash
npm install

```
Synthesize the Terraform Configuration: Run the synth command to generate the Terraform configuration files in the cdktf.out/ directory:

```bash
cdkft synth
```
Check the configuration plan
```bash
cdktf plan
```

Deploy the Infrastructure: Run the deploy command to apply the Terraform configuration and provision the AWS resources:

```bash
cdktf deploy
```

Destroy the Infrastructure: If you want to destroy the infrastructure, you can run the destroy command:

```bash
cdktf destroy
```
